#!/usr/bin/env python
import sys
import os

# Add parent directory to path to import supabase_utils
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from supabase_utils import generate_adopter_uuid

def analyze_simple_pattern(suffix):
    """Analyze if a 12-character suffix follows a very simple pattern"""
    print(f"Analyzing: '{suffix}'")
    
    unique_chars = set(suffix)
    print(f"Unique characters: {sorted(list(unique_chars))} (count: {len(unique_chars)})")
    
    # Check if it's numbers only or letters only
    is_numbers_only = suffix.isdigit()
    is_letters_only = suffix.isalpha()
    is_mixed = not (is_numbers_only or is_letters_only)
    
    print(f"Numbers only: {is_numbers_only}")
    print(f"Letters only: {is_letters_only}")
    print(f"Mixed (NOT ALLOWED): {is_mixed}")
    
    if is_mixed:
        print("❌ ERROR: Pattern mixes numbers and letters - NOT ALLOWED!")
        return False
    
    # Test for simple patterns
    patterns_found = []
    
    # 1. All same character (like 111111111111, aaaaaaaaaaaa)
    if len(unique_chars) == 1:
        char_type = "number" if is_numbers_only else "letter"
        patterns_found.append(f"All same {char_type}: '{list(unique_chars)[0]}'")
    
    # 2. Simple alternating pattern (like 121212121212, abababababab)
    elif len(unique_chars) == 2 and suffix == suffix[:2] * 6:
        char_type = "numbers" if is_numbers_only else "letters"
        patterns_found.append(f"Alternating {char_type}: '{suffix[:2]}' repeated 6 times")
    
    # 3. Check if it's just any simple pattern with ≤3 unique chars
    elif len(unique_chars) <= 3:
        char_type = "numbers" if is_numbers_only else "letters"
        patterns_found.append(f"Simple {char_type} pattern with {len(unique_chars)} unique characters")
    
    print(f"Patterns found: {patterns_found}")
    print(f"Is valid simple pattern: {len(patterns_found) > 0}")
    print("-" * 50)
    
    return len(patterns_found) > 0

def test_requested_patterns():
    """Test the specific patterns requested by the user"""
    print("=== Testing User-Requested Patterns ===\n")
    
    # Examples from user's request - SEPARATED numbers and letters
    requested_patterns = [
        # NUMBERS ONLY patterns
        "121212121212",  # alternating numbers
        "787878787878",  # alternating numbers
        "191919191919",  # alternating numbers
        "919191919191",  # alternating numbers
        "111111111111",  # all same number
        "545454545454",  # alternating numbers
        "999999999999",  # all same number
        
        # LETTERS ONLY patterns
        "abababababab",  # alternating letters
        "zzzzzzzzzzzz",  # all same letter
        "xyxyxyxyxyxy",  # alternating letters
        "cdcdcdcdcdcd",  # alternating letters
        "pqpqpqpqpqpq",  # alternating letters
        
        # INVALID patterns (should be rejected)
        "1a1a1a1a1a1a",  # number-letter mix - SHOULD FAIL
        "z9z9z9z9z9z9",  # letter-number mix - SHOULD FAIL
    ]
    
    print("Testing patterns from user examples:")
    valid_count = 0
    total_count = len(requested_patterns)
    
    for i, pattern in enumerate(requested_patterns):
        # Adjust to 12 characters if needed
        if len(pattern) < 12:
            pattern = pattern[:10] + pattern[0] * (12 - len(pattern))
        elif len(pattern) > 12:
            pattern = pattern[:12]
        
        print(f"\n--- Pattern {i+1}: {pattern} ---")
        
        # Check if this should be valid or invalid
        is_mixed = not (pattern.isdigit() or pattern.isalpha())
        should_be_valid = not is_mixed
        
        is_valid = analyze_simple_pattern(pattern)
        
        if should_be_valid and is_valid:
            print(f"✅ CORRECT: Valid pattern accepted")
            valid_count += 1
        elif not should_be_valid and not is_valid:
            print(f"✅ CORRECT: Invalid pattern rejected")
            valid_count += 1
        elif should_be_valid and not is_valid:
            print(f"❌ ERROR: Valid pattern rejected")
        else:
            print(f"❌ ERROR: Invalid pattern accepted")
    
    print(f"\n📊 Pattern Test Results:")
    print(f"   Correctly handled: {valid_count}/{total_count}")
    print(f"   Success rate: {valid_count/total_count*100:.1f}%")
    
    return valid_count == total_count

def test_generated_simple_patterns():
    """Test patterns generated by our simplified function"""
    print("=== Testing Generated Simple Patterns ===\n")
    
    all_valid = True
    pattern_types_seen = set()
    
    for i in range(15):  # Generate more to see variety
        print(f"Generated UUID {i+1}:")
        uuid_str = generate_adopter_uuid()
        
        # Extract suffix
        prefix = "5a1f43e5-b1e6-4c5c-bc5a-"
        suffix = uuid_str[len(prefix):]
        
        is_valid = analyze_simple_pattern(suffix)
        if not is_valid:
            all_valid = False
            print(f"ERROR: Generated non-simple pattern!")
        else:
            # Track pattern types
            unique_chars = set(suffix)
            if len(unique_chars) == 1:
                pattern_types_seen.add("all_same")
            elif len(unique_chars) == 2 and suffix == suffix[:2] * 6:
                pattern_types_seen.add("alternating")
            else:
                pattern_types_seen.add("other_simple")
        
        print()
    
    print(f"All generated patterns are simple: {all_valid}")
    print(f"Pattern types seen: {sorted(list(pattern_types_seen))}")
    print()
    return all_valid

def test_full_uuid_format():
    """Test that full UUIDs are valid"""
    print("=== Testing Full UUID Format ===\n")
    
    import uuid
    
    all_valid = True
    for i in range(5):
        uuid_str = generate_adopter_uuid()
        print(f"Testing UUID {i+1}: {uuid_str}")
        
        try:
            # Test if it's a valid UUID
            uuid_obj = uuid.UUID(uuid_str)
            print(f"✅ Valid UUID format")
            
            # Test prefix
            expected_prefix = "5a1f43e5-b1e6-4c5c-bc5a-"
            if uuid_str.startswith(expected_prefix):
                print(f"✅ Correct prefix")
            else:
                print(f"❌ Wrong prefix")
                all_valid = False
            
            # Test suffix length
            suffix = uuid_str[len(expected_prefix):]
            if len(suffix) == 12:
                print(f"✅ Correct suffix length")
            else:
                print(f"❌ Wrong suffix length: {len(suffix)}")
                all_valid = False
                
        except ValueError as e:
            print(f"❌ Invalid UUID: {e}")
            all_valid = False
        
        print("-" * 30)
    
    print(f"All UUIDs are valid: {all_valid}\n")
    return all_valid

if __name__ == "__main__":
    print("🧪 Testing Very Simple Pattern Generation\n")
    
    # Run all tests
    results = []
    
    print("=" * 60)
    results.append(test_requested_patterns())
    
    print("=" * 60)
    results.append(test_generated_simple_patterns())
    
    print("=" * 60)
    results.append(test_full_uuid_format())
    
    # Final summary
    print("=" * 60)
    print("🎯 Final Summary:")
    print(f"   User-requested patterns: {'✅ PASS' if results[0] else '❌ FAIL'}")
    print(f"   Generated simple patterns: {'✅ PASS' if results[1] else '❌ FAIL'}")
    print(f"   Full UUID format: {'✅ PASS' if results[2] else '❌ FAIL'}")
    
    if all(results):
        print(f"\n🎉 All tests passed! Simple pattern generation works perfectly.")
        print(f"\n📋 Pattern types available:")
        print(f"   • All same numbers: 111111111111, 777777777777")
        print(f"   • All same letters: aaaaaaaaaaaa, zzzzzzzzzzzz")
        print(f"   • Alternating numbers: 121212121212, 787878787878")
        print(f"   • Alternating letters: abababababab, xyxyxyxyxyxy")
        print(f"   • Number combinations: 191919191919, 545454545454")
        print(f"   • Letter combinations: cdcdcdcdcdcd, pqpqpqpqpqpq")
        print(f"\n⚠️  NO MIXING: Numbers and letters are kept separate!")
    else:
        print(f"\n❌ Some tests failed. Check the output above for details.")
    
    print(f"\n💡 Ready to use in your adoption system!") 